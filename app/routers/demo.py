# FILE: app/routers/demo.py
import asyncio
from fastapi import APIRouter, WebSocket, WebSocketDisconnect
from fastapi.responses import StreamingResponse

from app.utils.sse import sse_format


router = APIRouter()


@router.get(
    "/demo/stream",
    tags=["Demo"],
    summary="Демо‑пояснения в реальном времени",
    description="Поток серверных событий с пояснениями ключевых этапов работы системы.",
)
async def demo_stream(scenario: str = "default"):
    async def gen():
        messages = [
            ("demo:start", {
                "scenario": scenario, 
                "info": "Демонстрационный режим запущен. Система генерирует случайные числа для лотерейных тиражей с использованием криптографически безопасных методов."
            }),
            ("demo:entropy:sources", {
                "info": "Сбор энтропии из различных источников: RSS-новости, погодные данные по континентам, спутниковые снимки Солнца и Земли, системный генератор и временной джиттер."
            }),
            ("demo:entropy:processing", {
                "info": "Обработка сырой энтропии: данные хэшируются для получения равномерного распределения битов. Каждый источник вносит уникальный вклад в общую энтропию."
            }),
            ("demo:whitening:theory", {
                "info": "Вайтинг (экстрактор фон Неймана) применяется для устранения смещений в битовой последовательности. Удаляются пары одинаковых битов, оставляя только статистически независимые."
            }),
            ("demo:whitening:result", {
                "info": "После вайтинга получаем белёную битовую последовательность с равномерным распределением 0 и 1, готовую для криптографического использования."
            }),
            ("demo:seed:generation", {
                "info": "Создание криптографического сида: белёные биты хэшируются с помощью SHA-256 для получения детерминированного начального значения."
            }),
            ("demo:fingerprint", {
                "info": "Вычисление цифрового слепка (fingerprint) результата. Это позволяет в будущем проверить подлинность тиража и отсутствие манипуляций."
            }),
            ("demo:draw:preparation", {
                "info": "Подготовка к генерации тиража: инициализация генератора случайных чисел с полученным сидом для гарантии воспроизводимости."
            }),
            ("demo:draw:generation", {
                "info": "Генерация комбинации чисел методом случайной выборки без возврата. Гарантируется равномерное распределение и отсутствие смещений."
            }),
            ("demo:tests:overview", {
                "info": "Запуск статистических тестов для проверки случайности сгенерированной последовательности. Используется полный набор тестов NIST SP 800-22."
            }),
            ("demo:tests:nist", {
                "info": "Выполнение тестов NIST: монобитный тест, тест частот в блоке, тест серий, тест самого длинного прогона и другие специализированные тесты."
            }),
            ("demo:tests:analysis", {
                "info": "Анализ результатов тестов: вычисление p-значений для каждого теста. Последовательность считается случайной, если p-значения превышают порог значимости."
            }),
            ("demo:verification", {
                "info": "Возможности верификации: любой желающий может проверить результат тиража, используя опубликованный цифровой слепок и исходные биты."
            }),
            ("demo:security", {
                "info": "Гарантии безопасности: использование множества независимых источников энтропии делает невозможным предсказание или манипуляцию результатом."
            }),
            ("demo:finish", {
                "info": "Процесс завершён. Сгенерирована криптографически безопасная случайная комбинация с полным аудитом и возможностью независимой проверки."
            }),
        ]
        for ev, data in messages:
            yield sse_format(ev, data)
            await asyncio.sleep(0.8)  # Slightly longer delay for more detailed reading
    return StreamingResponse(gen(), media_type="text/event-stream")


@router.websocket("/demo/ws")
async def demo_ws(websocket: WebSocket):
    await websocket.accept()
    try:
        scenario = websocket.query_params.get("scenario", "default")
        # immediate ack
        await websocket.send_json({"event": "ready", "data": {"scenario": scenario}})

        messages = [
            ("demo:start", {
                "scenario": scenario, 
                "info": "Демонстрационный режим запущен. Система генерирует случайные числа для лотерейных тиражей с использованием криптографически безопасных методов."
            }),
            ("demo:entropy:sources", {
                "info": "Сбор энтропии из различных источников: RSS-новости, погодные данные по континентам, спутниковые снимки Солнца и Земли, системный генератор и временной джиттер."
            }),
            ("demo:entropy:processing", {
                "info": "Обработка сырой энтропии: данные хэшируются для получения равномерного распределения битов. Каждый источник вносит уникальный вклад в общую энтропию."
            }),
            ("demo:whitening:theory", {
                "info": "Вайтинг (экстрактор фон Неймана) применяется для устранения смещений в битовой последовательности. Удаляются пары одинаковых битов, оставляя только статистически независимые."
            }),
            ("demo:whitening:result", {
                "info": "После вайтинга получаем белёную битовую последовательность с равномерным распределением 0 и 1, готовую для криптографического использования."
            }),
            ("demo:seed:generation", {
                "info": "Создание криптографического сида: белёные биты хэшируются с помощью SHA-256 для получения детерминированного начального значения."
            }),
            ("demo:fingerprint", {
                "info": "Вычисление цифрового слепка (fingerprint) результата. Это позволяет в будущем проверить подлинность тиража и отсутствие манипуляций."
            }),
            ("demo:draw:preparation", {
                "info": "Подготовка к генерации тиража: инициализация генератора случайных чисел с полученным сидом для гарантии воспроизводимости."
            }),
            ("demo:draw:generation", {
                "info": "Генерация комбинации чисел методом случайной выборки без возврата. Гарантируется равномерное распределение и отсутствие смещений."
            }),
            ("demo:tests:overview", {
                "info": "Запуск статистических тестов для проверки случайности сгенерированной последовательности. Используется полный набор тестов NIST SP 800-22."
            }),
            ("demo:tests:nist", {
                "info": "Выполнение тестов NIST: монобитный тест, тест частот в блоке, тест серий, тест самого длинного прогона и другие специализированные тесты."
            }),
            ("demo:tests:analysis", {
                "info": "Анализ результатов тестов: вычисление p-значений для каждого теста. Последовательность считается случайной, если p-значения превышают порог значимости."
            }),
            ("demo:verification", {
                "info": "Возможности верификации: любой желающий может проверить результат тиража, используя опубликованный цифровой слепок и исходные биты."
            }),
            ("demo:security", {
                "info": "Гарантии безопасности: использование множества независимых источников энтропии делает невозможным предсказание или манипуляцию результатом."
            }),
            ("demo:finish", {
                "info": "Процесс завершён. Сгенерирована криптографически безопасная случайная комбинация с полным аудитом и возможностью независимой проверки."
            }),
        ]
        for ev, data in messages:
            await websocket.send_json({"event": ev, "data": {"stage": ev, "data": data, "time": 0.0}})
            await asyncio.sleep(0.8)  # Slightly longer delay for more detailed reading
        await websocket.send_json({"event": "final", "data": {"status": "completed"}})
    except WebSocketDisconnect:
        pass